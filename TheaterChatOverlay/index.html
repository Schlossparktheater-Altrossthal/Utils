<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Theater Chat Overlay</title>
  <style>
    :root {
      --bg: #0b141a;
      --panel: #111a20cc;
      --bubble-me: #005c4b;
      --bubble-them: #202c33;
      --bubble-shadow: 0 1px 0 rgba(0, 0, 0, 0.32);
      --bubble-tail-shadow: 0 2px 4px rgba(0, 0, 0, 0.18);
      --bubble-tail-width: 18px;
      --bubble-tail-height: 18px;
      --bubble-incoming-border: rgba(255, 255, 255, 0.04);
      --bubble-outgoing-border: rgba(9, 94, 84, 0.45);
      --bubble-incoming-fill:
        radial-gradient(140% 160% at 0% 0%, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0) 65%),
        radial-gradient(160% 200% at 100% 100%, rgba(0, 0, 0, 0.24), rgba(0, 0, 0, 0) 76%),
        var(--bubble-them);
      --bubble-outgoing-fill:
        radial-gradient(140% 160% at 0% 0%, rgba(255, 255, 255, 0.22), rgba(255, 255, 255, 0) 70%),
        radial-gradient(150% 210% at 100% 100%, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0) 78%),
        var(--bubble-me);
      --text: #e9edef;
      --muted: #96a1a8;
      --accent: #25d366;
      --bubble-max: 680px;
      --center-gap: 0px;
      --row-gap: clamp(8px, 2vw, 14px);
      --content-pad: clamp(14px, 2.4vw, 20px);
      --avatar-size: clamp(32px, 5vw, 40px);
      --gap: clamp(8px, 2vw, 16px);
      --message-gap: clamp(6px, 2vh, 12px);
      --radius: 18px;
      --shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
      --font-size-base: clamp(15px, 2.1vh, 19px);
      --font-size-small: clamp(12px, 1.8vh, 14px);
      --topbar-bg: linear-gradient(180deg, #075e54, #065249);
      --topbar-text: #ffffff;
      --topbar-icon: rgba(255, 255, 255, 0.95);
      --topbar-icon-hover: rgba(255, 255, 255, 0.08);
      --topbar-focus: rgba(255, 255, 255, 0.18);
      --topbar-subtext: rgba(255, 255, 255, 0.85);
      --topbar-shadow: 0 6px 22px rgba(3, 33, 25, 0.18);
      --topbar-avatar-border: rgba(255, 255, 255, 0.06);
      --topbar-online-border: rgba(0, 0, 0, 0.25);
      --scrim: radial-gradient(
        120% 120% at 80% 20%,
        transparent 0,
        rgba(0, 0, 0, 0.35) 60%,
        rgba(0, 0, 0, 0.65) 100%
      );
      --composer-bg: rgba(21, 33, 40, 0.92);
      --composer-border: rgba(255, 255, 255, 0.08);
      --composer-placeholder: rgba(204, 213, 218, 0.6);
      --composer-send: #00a884;
      --composer-send-shadow: 0 8px 24px rgba(0, 168, 132, 0.35);
      --composer-cursor: rgba(255, 255, 255, 0.75);
    }

    body {
      color-scheme: dark;
    }

    body.theme-light {
      color-scheme: light;
      --bg: #e5ddd5;
      --panel: #ffffffcc;
      --bubble-me: #d9fdd3;
      --bubble-them: #ffffff;
      --bubble-shadow: 0 1px 0 rgba(0, 0, 0, 0.12);
      --bubble-tail-shadow: 0 1px 2px rgba(15, 32, 42, 0.16);
      --bubble-incoming-border: rgba(0, 0, 0, 0.06);
      --bubble-outgoing-border: rgba(0, 0, 0, 0.08);
      --bubble-incoming-fill:
        radial-gradient(135% 150% at 0% 0%, rgba(255, 255, 255, 0.75), rgba(255, 255, 255, 0) 60%),
        radial-gradient(160% 200% at 100% 100%, rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0) 78%),
        var(--bubble-them);
      --bubble-outgoing-fill:
        radial-gradient(135% 150% at 0% 0%, rgba(255, 255, 255, 0.55), rgba(255, 255, 255, 0) 64%),
        radial-gradient(160% 200% at 100% 100%, rgba(0, 0, 0, 0.04), rgba(0, 0, 0, 0) 80%),
        var(--bubble-me);
      --text: #1f2c34;
      --muted: #4a575f;
      --shadow: 0 10px 24px rgba(15, 32, 42, 0.12);
      --topbar-bg: linear-gradient(180deg, #f0f2f5, #d9dde2);
      --topbar-text: #1f2c34;
      --topbar-icon: rgba(31, 44, 52, 0.92);
      --topbar-icon-hover: rgba(15, 32, 42, 0.12);
      --topbar-focus: rgba(7, 94, 84, 0.25);
      --topbar-subtext: rgba(31, 44, 52, 0.7);
      --topbar-shadow: 0 10px 24px rgba(15, 32, 42, 0.08);
      --topbar-avatar-border: rgba(15, 32, 42, 0.12);
      --topbar-online-border: rgba(7, 94, 84, 0.25);
      --scrim: radial-gradient(
        120% 120% at 80% 20%,
        transparent 0,
        rgba(32, 44, 51, 0.18) 60%,
        rgba(32, 44, 51, 0.32) 100%
      );
      --composer-bg: rgba(255, 255, 255, 0.92);
      --composer-border: rgba(0, 0, 0, 0.08);
      --composer-placeholder: rgba(46, 60, 67, 0.6);
      --composer-send: #008069;
      --composer-send-shadow: 0 8px 24px rgba(0, 128, 105, 0.22);
      --composer-cursor: rgba(40, 58, 66, 0.7);
    }

    html,
    body,
    .stage,
    .chat-wrap,
    .chat {
      height: 100%;
      min-height: 100%;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
      transition: background 0.35s ease, color 0.2s ease;
    }

    .stage {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .bg-media {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      opacity: 0.18;
      pointer-events: none;
    }

    .scrim {
      position: absolute;
      inset: 0;
      background: var(--scrim);
      z-index: 1;
      pointer-events: none;
      transition: background 0.35s ease;
    }

    .chat-wrap {
      position: relative;
      z-index: 2;
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: 0;
      width: 100%;
    }

    .chat {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 0;
      overflow: hidden;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--gap);
      background: var(--topbar-bg);
      padding: clamp(6px, 2.2vh, 14px) clamp(12px, 4vw, 22px);
      box-shadow: var(--topbar-shadow);
      color: var(--topbar-text);
      transition: background 0.35s ease, color 0.2s ease, box-shadow 0.35s ease;
    }

    .topbar .left {
      display: flex;
      align-items: center;
      gap: clamp(8px, 2vw, 14px);
      min-width: 0;
      flex: 1 1 auto;
    }

    .topbar button {
      border: none;
      background: transparent;
      padding: clamp(4px, 1.4vh, 8px);
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--topbar-icon);
      opacity: 0.95;
      transition: background 0.18s ease, transform 0.08s ease, color 0.2s ease;
      flex-shrink: 0;
      min-width: clamp(32px, 8vw, 42px);
      min-height: clamp(32px, 8vw, 42px);
    }

    .topbar button:hover {
      background: var(--topbar-icon-hover);
      transform: translateY(-1px);
    }

    .topbar button:active {
      transform: translateY(0);
    }

    .topbar button:focus-visible {
      outline: 2px solid var(--topbar-focus);
      outline-offset: 2px;
    }

    .topbar .group-avatar {
      width: clamp(36px, 8vw, 48px);
      height: clamp(36px, 8vw, 48px);
      border-radius: 50%;
      object-fit: cover;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.45);
      position: relative;
      border: 2px solid var(--topbar-avatar-border);
      flex-shrink: 0;
    }

    .topbar .group-avatar::after {
      content: '';
      position: absolute;
      right: 0.5px;
      bottom: 0.5px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #25d366;
      border: 2px solid var(--topbar-online-border);
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.12);
    }

    .topbar .info {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
      line-height: 1.1;
    }

    .topbar .title {
      font-size: clamp(0.9rem, 2.2vh, 1.35rem);
      font-weight: 700;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      color: var(--topbar-text);
      letter-spacing: 0.01em;
      transition: color 0.2s ease;
    }

    .topbar .participants {
      font-size: clamp(0.68rem, 1.6vh, 0.82rem);
      color: var(--topbar-subtext);
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: min(50vw, 260px);
      transition: color 0.2s ease;
    }

    .topbar .actions {
      display: flex;
      align-items: center;
      gap: clamp(4px, 1.6vw, 10px);
    }

    .topbar .icon-svg {
      width: clamp(18px, 3vw, 22px);
      height: clamp(18px, 3vw, 22px);
      fill: currentColor;
    }

    .bounded {
      width: min(min(56rem, 92vw), var(--bubble-max) + var(--avatar-size) + 90px);
      margin-inline: auto;
      box-sizing: border-box;
    }

    .scroll {
      flex: 1 1 auto;
      overflow-y: auto;
      overflow-x: hidden;
      padding: max(18px, env(safe-area-inset-top)) var(--content-pad) max(28px, env(safe-area-inset-bottom));
      scroll-behavior: smooth;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .scroll::-webkit-scrollbar {
      display: none;
    }

    .row {
      display: flex;
      align-items: flex-end;
      gap: var(--row-gap);
      margin-bottom: var(--message-gap);
      min-width: 0;
    }

    .row.them {
      justify-content: flex-start;
    }

    .row.me {
      justify-content: flex-end;
    }

    .avatar {
      width: var(--avatar-size);
      height: var(--avatar-size);
      border-radius: 50%;
      flex: 0 0 var(--avatar-size);
      object-fit: cover;
      box-shadow: var(--shadow);
    }

    .bubbles {
      display: flex;
      flex-direction: column;
      gap: 0;
      max-width: min(
        calc(100% - (var(--avatar-size) + var(--row-gap) * 1.5) - var(--center-gap)),
        var(--bubble-max)
      );
      min-width: 0;
    }

    .row .bubbles {
      flex: 1 1 auto;
      min-width: 0;
      width: auto;
    }

    .row.them .bubbles {
      margin-left: 4px;
      align-items: flex-start;
    }

    .row.me .bubbles {
      margin-right: 4px;
      align-items: flex-end;
    }

    .bubble {
      max-width: min(
        calc(100% - (var(--avatar-size) + var(--row-gap) * 1.5) - var(--center-gap)),
        var(--bubble-max)
      );
      box-sizing: border-box;
      word-break: break-word;
      overflow-wrap: anywhere;
      background: var(--bubble-fill, var(--bubble-incoming-fill));
      padding: clamp(8px, 1.6vh, 12px) clamp(10px, 2vw, 16px);
      border-radius: var(--radius);
      box-shadow: var(--bubble-shadow);
      border: 1px solid var(--bubble-border, var(--bubble-incoming-border));
      line-height: 1.35;
      font-size: var(--font-size-base);
      position: relative;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: clamp(6px, 1.6vh, 10px);
      transition: background 0.35s ease, color 0.2s ease, box-shadow 0.35s ease;
      --bubble-tail-color: var(--bubble-them);
    }

    .row.them .bubble {
      --bubble-fill: var(--bubble-incoming-fill);
      --bubble-border: var(--bubble-incoming-border);
      --bubble-tail-color: var(--bubble-them);
    }

    .row.me .bubble {
      --bubble-fill: var(--bubble-outgoing-fill);
      --bubble-border: var(--bubble-outgoing-border);
      --bubble-tail-color: var(--bubble-me);
    }

    .bubble .text {
      white-space: pre-wrap;
    }

    .quote {
      display: block;
      background: rgba(0, 0, 0, 0.06);
      color: var(--muted);
      padding: 8px;
      border-radius: 8px;
      margin-bottom: 4px;
      font-size: 0.86em;
      border-left: 4px solid rgba(255, 255, 255, 0.06);
      max-width: 100%;
      overflow: hidden;
    }

    .quote .q-author {
      font-weight: 700;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }

    .quote .q-text {
      display: block;
      color: var(--muted);
      opacity: 0.95;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    body.theme-light .quote {
      background: rgba(7, 94, 84, 0.08);
      border-left-color: rgba(7, 94, 84, 0.25);
      color: rgba(31, 44, 52, 0.78);
    }

    body.theme-light .quote .q-author {
      color: rgba(7, 94, 84, 0.82);
    }

    body.theme-light .quote .q-text {
      color: rgba(31, 44, 52, 0.7);
    }

    .meta {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 0.78em;
      color: var(--muted);
    }

    .meta .name {
      font-weight: 600;
    }

    .typing {
      display: inline-flex;
      gap: 4px;
      align-items: center;
      padding: 4px 0;
    }

    #typingRow.animating-in {
      animation: composer-slide-in 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    #typingRow.animating-out {
      animation: composer-slide-out 0.42s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    #typingRow.animating-in .bubble {
      animation: composer-inner-in 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    #typingRow.animating-out .bubble {
      animation: composer-inner-out 0.42s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #b7c1c6;
      opacity: 0.3;
      transform-origin: center;
    }

    body.theme-light .dot {
      background: #8aa7ad;
    }

    .composer {
      --composer-pad-inline: clamp(12px, 4vw, 20px);
      --composer-pad-top: clamp(6px, 1.8vh, 12px);
      --composer-pad-bottom: max(16px, env(safe-area-inset-bottom) + 10px);
      padding-block-start: var(--composer-pad-top);
      padding-block-end: var(--composer-pad-bottom);
      padding-inline: var(--composer-pad-inline);
      background: linear-gradient(180deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.32) 100%);
      pointer-events: none;
      display: grid;
      grid-template-rows: 1fr;
      overflow: hidden;
      transition:
        grid-template-rows 0.45s cubic-bezier(0.4, 0, 0.2, 1),
        padding-block-start 0.45s cubic-bezier(0.4, 0, 0.2, 1),
        padding-block-end 0.45s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .composer.hidden {
      --composer-pad-top: 0px;
      --composer-pad-bottom: max(0px, env(safe-area-inset-bottom));
      grid-template-rows: 0fr;
      opacity: 0;
      transform: translateY(28px);
    }

    .composer-inner {
      display: flex;
      align-items: flex-end;
      gap: clamp(6px, 1.8vw, 14px);
      width: min(min(56rem, 92vw), var(--bubble-max) + var(--avatar-size) + 90px);
      margin-inline: auto;
      transition: opacity 0.35s ease, transform 0.35s ease;
    }

    .composer.hidden .composer-inner {
      opacity: 0;
      transform: translateY(12px);
    }

    .composer.animating-in,
    .composer.animating-out {
      grid-template-rows: 1fr;
    }

    .composer.animating-in {
      animation: composer-slide-in 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    .composer.animating-out {
      animation: composer-slide-out 0.42s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    .composer.animating-in .composer-inner {
      animation: composer-inner-in 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    .composer.animating-out .composer-inner {
      animation: composer-inner-out 0.42s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    .composer-field {
      flex: 1 1 auto;
      min-width: 0;
      position: relative;
      display: flex;
      align-items: center;
      min-height: clamp(44px, 7vh, 58px);
      padding: clamp(10px, 2vh, 14px) clamp(16px, 4vw, 22px);
      background: var(--composer-bg);
      border: 1px solid var(--composer-border);
      border-radius: clamp(24px, 4vw, 32px);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
      overflow: hidden;
    }

    .composer-textwrap {
      position: relative;
      flex: 1 1 auto;
      display: block;
      width: 100%;
      min-width: 0;
      font-size: var(--font-size-base);
      color: var(--text);
      pointer-events: none;
    }

    .composer-placeholder {
      position: absolute;
      inset-inline-start: 0;
      top: 0;
      font-size: var(--font-size-base);
      color: var(--composer-placeholder);
      opacity: 1;
      transform: translateY(2px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
    }

    .composer.has-text .composer-placeholder,
    .composer.is-typing .composer-placeholder,
    .composer.is-sending .composer-placeholder {
      opacity: 0;
      transform: translateY(-6px);
    }

    .composer-text {
      display: inline-block;
      max-width: 100%;
      white-space: pre-wrap;
      word-break: break-word;
      min-height: 1.35em;
      vertical-align: bottom;
    }

    .composer-cursor {
      display: none;
      vertical-align: bottom;
      width: 2px;
      background: var(--composer-cursor);
      border-radius: 1px;
      align-self: stretch;
      animation: composer-blink 1s steps(2, start) infinite;
      margin-inline-start: 2px;
    }

    .composer:not(.hidden) .composer-cursor {
      display: inline-block;
    }

    @keyframes composer-blink {
      0%,
      45% {
        opacity: 1;
      }
      55%,
      100% {
        opacity: 0;
      }
    }

    @keyframes composer-slide-in {
      0% {
        opacity: 0;
        transform: translateY(40px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes composer-slide-out {
      0% {
        opacity: 1;
        transform: translateY(0);
      }
      100% {
        opacity: 0;
        transform: translateY(36px);
      }
    }

    @keyframes composer-inner-in {
      0% {
        opacity: 0;
        transform: translateY(18px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes composer-inner-out {
      0% {
        opacity: 1;
        transform: translateY(0);
      }
      100% {
        opacity: 0;
        transform: translateY(12px);
      }
    }

    .composer-buttons {
      display: flex;
      align-items: center;
      gap: clamp(6px, 2vw, 12px);
      pointer-events: none;
    }

    .composer-btn {
      width: clamp(32px, 4vw, 38px);
      height: clamp(32px, 4vw, 38px);
      border-radius: 50%;
      border: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      color: var(--muted);
      opacity: 0.85;
      pointer-events: none;
      flex-shrink: 0;
    }

    .composer-btn svg {
      width: clamp(18px, 2.6vw, 22px);
      height: clamp(18px, 2.6vw, 22px);
      fill: none;
      stroke: currentColor;
      stroke-width: 1.8;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .composer-btn.primary {
      width: clamp(46px, 6vh, 54px);
      height: clamp(46px, 6vh, 54px);
      color: #fff;
      background: rgba(149, 163, 170, 0.28);
      box-shadow: none;
      transition: background 0.28s ease, transform 0.28s ease, color 0.28s ease, box-shadow 0.28s ease;
    }

    .composer.has-text .composer-btn.primary,
    .composer.is-ready .composer-btn.primary {
      background: var(--composer-send);
      box-shadow: var(--composer-send-shadow);
      color: #fff;
    }

    .composer.is-sending .composer-btn.primary {
      transform: translateX(4px) scale(1.05);
    }

    .composer-btn.primary svg {
      fill: currentColor;
      stroke: none;
    }

    .composer-btn.primary .icon-send {
      display: none;
    }

    .composer.has-text .composer-btn.primary .icon-mic,
    .composer.is-ready .composer-btn.primary .icon-mic,
    .composer.is-sending .composer-btn.primary .icon-mic {
      display: none;
    }

    .composer.has-text .composer-btn.primary .icon-send,
    .composer.is-ready .composer-btn.primary .icon-send,
    .composer.is-sending .composer-btn.primary .icon-send {
      display: block;
    }

    @media (prefers-reduced-motion: reduce) {
      .composer,
      .composer-inner,
      #typingRow,
      #typingRow .bubble {
        transition: none !important;
        transform: none !important;
        animation: none !important;
      }
    }

    .media {
      border-radius: 12px;
      overflow: hidden;
      max-height: 42vh;
      aspect-ratio: 16 / 9;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.2);
    }

    .media[data-loaded="1"] {
      aspect-ratio: auto;
    }

    .media > img,
    .media > video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .panel {
      position: fixed;
      right: clamp(12px, 3vw, 24px);
      bottom: clamp(12px, 4vh, 28px);
      z-index: 3;
      width: min(420px, 92vw);
      background: var(--panel);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: grid;
      gap: 8px;
      padding: clamp(10px, 2vh, 16px);
      font-size: 14px;
      backdrop-filter: blur(6px);
      transition: background 0.35s ease, color 0.2s ease, box-shadow 0.35s ease;
    }

    .panel h3 {
      margin: 0 0 4px;
      font-size: 14px;
      opacity: 0.9;
    }

    .panel input,
    .panel textarea,
    .panel select,
    .panel button {
      width: 100%;
      box-sizing: border-box;
      border: 1px solid #22333b;
      background: #0c1419;
      color: #e1e6ea;
      border-radius: 10px;
      padding: 8px 10px;
      font: inherit;
      transition: background 0.25s ease, color 0.2s ease, border 0.25s ease;
    }

    .panel button {
      cursor: pointer;
      background: #17313f;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .panel button:hover {
      background: #1f3f52;
    }

    body.theme-light .panel {
      background: rgba(255, 255, 255, 0.88);
      color: #1f2c34;
      box-shadow: 0 12px 26px rgba(15, 32, 42, 0.14);
    }

    body.theme-light .panel input,
    body.theme-light .panel textarea,
    body.theme-light .panel select {
      background: rgba(240, 244, 246, 0.95);
      border: 1px solid rgba(38, 53, 61, 0.12);
      color: #1f2c34;
    }

    body.theme-light .panel button {
      background: #dcf8c6;
      color: #1f2c34;
    }

    body.theme-light .panel button:hover {
      background: #c7eab5;
    }

    .row2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .hidden {
      display: none !important;
    }

    body.trans {
      background: transparent;
      --bg: transparent;
    }

    body.trans .bg-media,
    body.trans .scrim {
      display: none;
    }

    @media (max-width: 600px) {
      :root {
        --center-gap: clamp(24px, 12vw, 72px);
      }

      .topbar {
        padding: 8px 12px;
      }

      .topbar .actions {
        margin-left: auto;
      }
    }

    @media (max-width: 480px) {
      .topbar {
        padding: 6px 10px;
        gap: 8px;
      }

      .topbar .left {
        gap: 8px;
      }

      .topbar button {
        padding: 4px;
        min-width: 32px;
        min-height: 32px;
        border-radius: 10px;
      }

      .topbar .group-avatar {
        width: 36px;
        height: 36px;
      }

      .topbar .title {
        font-size: clamp(0.85rem, 4.4vw, 1rem);
      }

      .topbar .participants {
        font-size: clamp(0.64rem, 3.6vw, 0.72rem);
        max-width: 60vw;
      }

      .topbar .actions {
        gap: 4px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }

    /* --- Cluster-Layout & Abstände --- */
    :root {
      --cluster-gap: 4px;
      --cluster-radius: 18px;
      --cluster-tight: 8px;
    }

    .bubbles .bubble + .bubble {
      margin-top: var(--cluster-gap);
    }

    .bubble {
      border-radius: var(--cluster-radius);
    }

    .bubble .meta {
      display: none;
    }

    /* Positionsklassen: werden via JS gesetzt */
    .bubble.is-single {
      border-radius: var(--cluster-radius);
    }

    .bubble.is-first {}

    .bubble.is-middle {}

    .bubble.is-last {}

    /* Incoming (them): asymmetrische Radien, damit Bubbles zusammenfließen */
    .row.them .bubble.is-first {
      border-top-left-radius: var(--cluster-radius);
      border-top-right-radius: var(--cluster-radius);
      border-bottom-right-radius: var(--cluster-tight);
      border-bottom-left-radius: var(--cluster-radius);
    }

    .row.them .bubble.is-middle {
      border-top-left-radius: var(--cluster-tight);
      border-top-right-radius: var(--cluster-radius);
      border-bottom-right-radius: var(--cluster-tight);
      border-bottom-left-radius: var(--cluster-radius);
    }

    .row.them .bubble.is-last {
      border-top-left-radius: var(--cluster-tight);
      border-top-right-radius: var(--cluster-radius);
      border-bottom-right-radius: var(--cluster-radius);
      border-bottom-left-radius: var(--cluster-radius);
    }

    /* Outgoing (me) */
    .row.me .bubble.is-first {
      border-top-left-radius: var(--cluster-radius);
      border-top-right-radius: var(--cluster-radius);
      border-bottom-left-radius: var(--cluster-tight);
      border-bottom-right-radius: var(--cluster-radius);
    }

    .row.me .bubble.is-middle {
      border-top-left-radius: var(--cluster-radius);
      border-top-right-radius: var(--cluster-tight);
      border-bottom-left-radius: var(--cluster-tight);
      border-bottom-right-radius: var(--cluster-radius);
    }

    .row.me .bubble.is-last {
      border-top-left-radius: var(--cluster-radius);
      border-top-right-radius: var(--cluster-tight);
      border-bottom-left-radius: var(--cluster-radius);
      border-bottom-right-radius: var(--cluster-radius);
    }

    /* Meta nur bei first/single sichtbar */
    .bubble.is-first .meta,
    .bubble.is-single .meta {
      display: flex;
    }

    /* Tail (nur bei last/single) */
    .bubble::after {
      content: '';
      position: absolute;
      bottom: -4px;
      width: var(--bubble-tail-width);
      height: var(--bubble-tail-height);
      border-radius: var(--bubble-tail-width);
      display: none;
      background: var(--bubble-tail-color);
      box-shadow: var(--bubble-tail-shadow);
      transform-origin: bottom center;
    }

    .row.them .bubble.is-last::after,
    .row.them .bubble.is-single::after {
      display: block;
      left: calc(var(--bubble-tail-width) * -0.55);
      transform: rotate(38deg);
    }

    .row.me .bubble.is-last::after,
    .row.me .bubble.is-single::after {
      display: block;
      right: calc(var(--bubble-tail-width) * -0.55);
      transform: rotate(-38deg);
    }

    body.theme-light .row.them .bubble.is-last::after,
    body.theme-light .row.them .bubble.is-single::after,
    body.theme-light .row.me .bubble.is-last::after,
    body.theme-light .row.me .bubble.is-single::after {
      box-shadow: var(--bubble-tail-shadow), 0 0 0 1px rgba(0, 0, 0, 0.04) inset;
    }

    /* Mini-Optimierung */
    .bubble .text {
      line-height: 1.4;
    }

    .bubble .text br + br {
      line-height: 0;
    }

    .row.them,
    .row.me {
      gap: 10px;
    }
  </style>
</head>
<body class="theme-dark">
  <svg xmlns="http://www.w3.org/2000/svg" style="position:absolute;width:0;height:0;overflow:hidden;">
    <symbol id="icon-arrow" viewBox="0 0 24 24" fill="currentColor">
      <path d="M15.54 3.88a1 1 0 0 1 0 1.41L10.83 10l4.71 4.71a1 1 0 1 1-1.41 1.41l-5.42-5.41a1 1 0 0 1 0-1.42l5.42-5.41a1 1 0 0 1 1.41 0z" />
    </symbol>
    <symbol id="icon-video" viewBox="0 0 24 24" fill="currentColor">
      <path d="M16 7a2 2 0 0 1 2 2v1.17l3.11-2.07A1 1 0 0 1 22 9v6a1 1 0 0 1-1.62.78L18 13.83V15a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h12z" />
    </symbol>
    <symbol id="icon-phone" viewBox="0 0 24 24" fill="currentColor">
      <path d="M6.62 10.79a15.09 15.09 0 0 0 6.59 6.59l2.2-2.2a1 1 0 0 1 1.01-.24c1.11.37 2.3.57 3.58.57a1 1 0 0 1 1 1V21a1 1 0 0 1-1 1C10.85 22 2 13.15 2 2a1 1 0 0 1 1-1h3.29a1 1 0 0 1 1 1c0 1.28.2 2.47.57 3.58a1 1 0 0 1-.25 1.01z" />
    </symbol>
    <symbol id="icon-info" viewBox="0 0 24 24" fill="currentColor">
      <path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 4a1.3 1.3 0 1 1-1.3 1.3A1.3 1.3 0 0 1 12 6zm1.75 11h-3.5a1 1 0 0 1 0-2h.75v-3h-.5a1 1 0 0 1 0-2h1.5a1 1 0 0 1 1 1v4h.75a1 1 0 0 1 0 2z" />
    </symbol>
    <symbol id="icon-smile" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
      <circle cx="12" cy="12" r="9" />
      <circle cx="9" cy="10" r="1.1" fill="currentColor" stroke="none" />
      <circle cx="15" cy="10" r="1.1" fill="currentColor" stroke="none" />
      <path d="M8.5 14.75a5 5 0 0 0 7 0" stroke-linecap="round" />
    </symbol>
    <symbol id="icon-attach" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
      <path d="M7.5 12.25V7a4.5 4.5 0 0 1 9 0v7a3 3 0 0 1-6 0V8.5" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-camera" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
      <path d="M4 7.5A2.5 2.5 0 0 1 6.5 5h1.1l1.2-2h6.4l1.2 2h1.1A2.5 2.5 0 0 1 20 7.5v8A2.5 2.5 0 0 1 17.5 18H6.5A2.5 2.5 0 0 1 4 15.5z" />
      <circle cx="12" cy="12" r="3.5" />
      <circle cx="18" cy="9" r="0.8" fill="currentColor" stroke="none" />
    </symbol>
    <symbol id="icon-mic" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
      <path d="M12 3a3 3 0 0 1 3 3v5a3 3 0 0 1-6 0V6a3 3 0 0 1 3-3z" />
      <path d="M5 11a7 7 0 0 0 14 0" stroke-linecap="round" />
      <path d="M12 18v3" stroke-linecap="round" />
    </symbol>
    <symbol id="icon-send" viewBox="0 0 24 24" fill="currentColor">
      <path d="M3.42 2.58a.75.75 0 0 1 .86-.16l16.5 7.5a.75.75 0 0 1 0 1.36l-16.5 7.5A.75.75 0 0 1 3 18.12l2.34-2.34a1 1 0 0 0 .29-.71v-2.46a.5.5 0 0 1 .5-.5h4.6a.6.6 0 0 0 .24-1.15L5.63 9.4a1 1 0 0 1-.62-.92V4.09a.75.75 0 0 1 .41-.67z" />
    </symbol>
  </svg>

  <div class="stage" id="stage">
    <video id="bgVideo" class="bg-media" autoplay muted loop playsinline></video>
    <img id="bgImage" class="bg-media" alt="" />
    <div class="scrim" id="scrim"></div>

    <div class="chat-wrap">
      <div class="chat">
        <header class="topbar" id="chatHeader">
          <div class="left">
            <button class="back" aria-label="Zurück">
              <svg class="icon-svg" aria-hidden="true"><use href="#icon-arrow"></use></svg>
            </button>
            <img
              class="group-avatar"
              src="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f3eb.svg"
              alt="Schulsymbol"
            />
            <div class="info">
              <div class="title">The never ending messages (Klasse 8a)</div>
              <div id="participants" class="participants">Teilnehmer: —</div>
            </div>
          </div>
          <div class="actions" aria-hidden="true">
            <button class="icon" aria-label="Videoanruf">
              <svg class="icon-svg"><use href="#icon-video"></use></svg>
            </button>
            <button class="icon" aria-label="Sprachanruf">
              <svg class="icon-svg"><use href="#icon-phone"></use></svg>
            </button>
            <button class="icon" aria-label="Gruppeninfos">
              <svg class="icon-svg"><use href="#icon-info"></use></svg>
            </button>
          </div>
        </header>
        <div id="scroll" class="scroll bounded"></div>
        <div id="typingRow" class="row them hidden bounded" aria-live="polite">
          <img id="typingAvatar" class="avatar" src="https://i.pravatar.cc/64?img=32" alt="avatar" />
          <div class="bubble">
            <span class="typing" aria-hidden="true">
              <span class="dot"></span>
              <span class="dot"></span>
              <span class="dot"></span>
            </span>
          </div>
        </div>
        <div id="composer" class="composer hidden" aria-live="polite">
          <div class="composer-inner">
            <button class="composer-btn" aria-hidden="true">
              <svg class="icon-svg"><use href="#icon-smile"></use></svg>
            </button>
            <div class="composer-field">
              <div class="composer-textwrap">
                <div id="composerPlaceholder" class="composer-placeholder">Nachricht</div>
                <div id="composerText" class="composer-text"></div>
                <span class="composer-cursor" aria-hidden="true"></span>
              </div>
            </div>
            <div class="composer-buttons" aria-hidden="true">
              <button class="composer-btn" aria-hidden="true">
                <svg class="icon-svg"><use href="#icon-attach"></use></svg>
              </button>
              <button class="composer-btn" aria-hidden="true">
                <svg class="icon-svg"><use href="#icon-camera"></use></svg>
              </button>
            </div>
            <button id="composerSend" class="composer-btn primary" aria-hidden="true">
              <svg class="icon-svg icon-mic"><use href="#icon-mic"></use></svg>
              <svg class="icon-svg icon-send"><use href="#icon-send"></use></svg>
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="panel hidden" id="panel">
      <h3>Live Eingabe (Taste C ein/aus)</h3>
      <div class="row2">
        <select id="role">
          <option value="them">Publikum</option>
          <option value="me">Protagonist</option>
        </select>
        <input id="name" placeholder="Name" value="Anna" />
      </div>
      <textarea id="text" rows="3" placeholder="Nachricht…"></textarea>
      <input id="quoteAuthor" placeholder="(Optional) Zitat: Name" />
      <input id="quoteText" placeholder="(Optional) Zitat: Text" />
      <div class="row2">
        <input id="avatar" placeholder="Avatar-URL" value="https://i.pravatar.cc/64?img=12" />
        <input id="media" placeholder="Medien-URL (Bild/Video)" />
      </div>
      <div class="row2">
        <button id="send">Senden</button>
        <button id="demo">Demo starten</button>
      </div>
      <div class="row2">
        <button id="clear">Leeren</button>
        <button id="bgbtn">Hintergrund setzen</button>
      </div>
      <input id="bgurl" placeholder="BG Bild/Video URL" />
    </div>
  </div>

  <audio
    id="snd"
    preload="auto"
    src="https://assets.mixkit.co/active_storage/sfx/2574/2574-preview.mp3"
  ></audio>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="./offline-chat.js"></script>
  <script>
    const qs = (key, fallback = null) => new URLSearchParams(location.search).get(key) ?? fallback;
    const scrollEl = document.getElementById('scroll');
    const typingRow = document.getElementById('typingRow');
    const typingAvatar = document.getElementById('typingAvatar');
    const composer = document.getElementById('composer');
    const composerText = document.getElementById('composerText');
    const composerPlaceholder = document.getElementById('composerPlaceholder');
    const composerAnimationNames = {
      enter: 'composer-slide-in',
      exit: 'composer-slide-out',
    };

    if (typingRow) {
      typingRow.addEventListener('animationend', (event) => {
        if (event.animationName === composerAnimationNames.enter) {
          if (typingRow.classList.contains('animating-in')) {
            typingRow.classList.remove('animating-in');
          }
          return;
        }
        if (event.animationName === composerAnimationNames.exit) {
          if (typingRow.classList.contains('animating-out')) {
            typingRow.classList.remove('animating-out');
            typingRow.classList.add('hidden');
          }
        }
      });
    }

    if (composer) {
      composer.addEventListener('animationend', (event) => {
        if (event.animationName === composerAnimationNames.enter) {
          if (composer.classList.contains('animating-in')) {
            composer.classList.remove('animating-in');
          }
          return;
        }
        if (event.animationName === composerAnimationNames.exit) {
          if (composer.classList.contains('animating-out')) {
            composer.classList.remove('animating-out');
            composer.classList.add('hidden');
          }
        }
      });
    }
    const snd = document.getElementById('snd');
    const FEATURES = { readTicks: false, reactions: false };
    const panel = document.getElementById('panel');
    const bgImg = document.getElementById('bgImage');
    const bgVid = document.getElementById('bgVideo');

    const tonePresets = {
      default: 'https://assets.mixkit.co/active_storage/sfx/2574/2574-preview.mp3',
      soft: 'https://assets.mixkit.co/active_storage/sfx/195/195-preview.mp3',
      click: 'https://assets.mixkit.co/active_storage/sfx/1007/1007-preview.mp3',
      chime: 'https://assets.mixkit.co/active_storage/sfx/2561/2561-preview.mp3'
    };

    const reduceMotionQuery = matchMedia('(prefers-reduced-motion: reduce)');
    let prefersReducedMotion = reduceMotionQuery.matches;
    if (reduceMotionQuery.addEventListener) {
      reduceMotionQuery.addEventListener('change', (e) => {
        prefersReducedMotion = e.matches;
      });
    } else if (reduceMotionQuery.addListener) {
      reduceMotionQuery.addListener((e) => {
        prefersReducedMotion = e.matches;
      });
    }

    const liveTimers = new Set();

    function setTrackedTimeout(fn, ms) {
      const id = setTimeout(() => {
        liveTimers.delete(id);
        fn();
      }, ms);
      liveTimers.add(id);
      return id;
    }

    function setTrackedInterval(fn, ms) {
      const id = setInterval(fn, ms);
      liveTimers.add(id);
      return id;
    }

    function clearTrackedTimer(id) {
      clearTimeout(id);
      clearInterval(id);
      liveTimers.delete(id);
    }

    function clearAllTimers() {
      for (const id of Array.from(liveTimers)) {
        clearTimeout(id);
        clearInterval(id);
      }
      liveTimers.clear();
      clearComposerTimers();
    }

    let smoothScrollAnim = null;
    let composerTypingTimer = null;
    let composerSendTimer = null;

    function cancelSmoothScroll() {
      if (smoothScrollAnim) {
        cancelAnimationFrame(smoothScrollAnim);
        smoothScrollAnim = null;
      }
    }

    function smoothScrollTo(target, duration = 600) {
      cancelSmoothScroll();
      if (prefersReducedMotion) {
        scrollEl.scrollTop = target;
        return;
      }
      const start = scrollEl.scrollTop;
      const change = target - start;
      const startTime = performance.now();
      const easeOutCubic = (t) => (--t) * t * t + 1;

      function animate(now) {
        const t = Math.min(1, (now - startTime) / duration);
        const val = start + change * easeOutCubic(t);
        scrollEl.scrollTop = val;
        if (t < 1) {
          smoothScrollAnim = requestAnimationFrame(animate);
        } else {
          smoothScrollAnim = null;
        }
      }

      smoothScrollAnim = requestAnimationFrame(animate);
    }

    function isUserNearBottom(threshold = 96) {
      try {
        return scrollEl.scrollHeight - (scrollEl.scrollTop + scrollEl.clientHeight) < threshold;
      } catch (err) {
        return true;
      }
    }

    let userLocked = false;
    let lockTimerId = null;

    function setUserLock() {
      userLocked = true;
      if (lockTimerId) {
        clearTrackedTimer(lockTimerId);
      }
      lockTimerId = setTrackedTimeout(() => {
        userLocked = false;
        lockTimerId = null;
        maybeAutoScroll(360);
      }, 1500);
    }

    scrollEl.addEventListener('wheel', setUserLock, { passive: true });
    scrollEl.addEventListener('touchstart', setUserLock, { passive: true });
    scrollEl.addEventListener('pointerdown', setUserLock, { passive: true });

    function maybeAutoScroll(duration = 420) {
      if (userLocked) return;
      if (!isUserNearBottom()) return;
      smoothScrollTo(scrollEl.scrollHeight, duration);
    }

    let lastTypingFollow = 0;

    function scrollFollowDuringTyping() {
      const now = performance.now();
      if (now - lastTypingFollow > 80) {
        maybeAutoScroll(380);
        lastTypingFollow = now;
      }
    }

    function setComposerTextValue(value = '') {
      if (!composerText) return;
      composerText.textContent = value;
      if (!composer) return;
      if (value) composer.classList.add('has-text');
      else composer.classList.remove('has-text');
    }

    function clearComposerTimers() {
      if (composerTypingTimer) {
        clearTrackedTimer(composerTypingTimer);
        composerTypingTimer = null;
      }
      if (composerSendTimer) {
        clearTrackedTimer(composerSendTimer);
        composerSendTimer = null;
      }
    }

    function playComposerEnterAnimation() {
      if (!composer) return;
      composer.classList.remove('animating-out');
      if (prefersReducedMotion) {
        composer.classList.remove('hidden');
        composer.classList.remove('animating-in');
        return;
      }

      const alreadyVisible = !composer.classList.contains('hidden');
      composer.classList.remove('hidden');
      if (alreadyVisible && composer.classList.contains('animating-in')) return;
      // Force a reflow so the animation restarts reliably.
      void composer.offsetWidth;
      composer.classList.add('animating-in');
    }

    function playComposerExitAnimation() {
      if (!composer) return;
      if (prefersReducedMotion) {
        composer.classList.remove('animating-in', 'animating-out');
        composer.classList.add('hidden');
        return;
      }

      if (composer.classList.contains('hidden')) return;
      composer.classList.remove('animating-in');
      // Force a reflow before starting the exit animation so it plays every time.
      void composer.offsetWidth;
      composer.classList.add('animating-out');
    }

    function playTypingRowEnterAnimation() {
      if (!typingRow) return;
      typingRow.classList.remove('hidden', 'animating-out');
      if (prefersReducedMotion) {
        typingRow.classList.remove('animating-in');
        return;
      }
      // Force a reflow so the animation restarts reliably.
      void typingRow.offsetWidth;
      typingRow.classList.add('animating-in');
    }

    function playTypingRowExitAnimation() {
      if (!typingRow) return;
      if (prefersReducedMotion) {
        typingRow.classList.remove('animating-in', 'animating-out');
        typingRow.classList.add('hidden');
        return;
      }
      if (typingRow.classList.contains('hidden')) return;
      typingRow.classList.remove('animating-in');
      // Force a reflow before starting the exit animation so it plays every time.
      void typingRow.offsetWidth;
      typingRow.classList.add('animating-out');
    }

    function showComposerShell() {
      if (!composer) return;
      playComposerEnterAnimation();
      composer.classList.remove('is-ready', 'is-sending');
      composer.classList.add('is-typing');
    }

    function hideComposerShell() {
      if (!composer) return;
      clearComposerTimers();
      setComposerTextValue('');
      composer.classList.remove('is-typing', 'is-ready', 'is-sending');
      playComposerExitAnimation();
    }

    function typeComposerSequence(text, duration, onComplete) {
      if (!composer || !composerText) {
        if (typeof onComplete === 'function') onComplete();
        return;
      }

      const content = typeof text === 'string' ? text : '';
      const targetDuration =
        Number.isFinite(duration) && duration > 0 ? duration : typingDurationFor(content);

      clearComposerTimers();
      showComposerShell();
      setComposerTextValue('');
      composer.classList.remove('is-ready', 'is-sending');

      if (!content) {
        composer.classList.remove('is-typing');
        composerSendTimer = setTrackedTimeout(() => {
          composerSendTimer = null;
          if (typeof onComplete === 'function') onComplete();
        }, 150);
        return;
      }

      if (prefersReducedMotion || targetDuration <= 0) {
        setComposerTextValue(content);
        composer.classList.remove('is-typing');
        composer.classList.add('is-ready');
        composerSendTimer = setTrackedTimeout(() => {
          composerSendTimer = null;
          composer.classList.add('is-sending');
          if (typeof onComplete === 'function') onComplete();
        }, 200);
        return;
      }

      composer.classList.add('is-typing');
      let index = 0;
      const total = content.length;
      const step = Math.max(24, Math.round(targetDuration / Math.max(1, total)));

      composerTypingTimer = setTrackedInterval(() => {
        index += 1;
        setComposerTextValue(content.slice(0, index));
        scrollFollowDuringTyping();
        if (index >= total) {
          if (composerTypingTimer) {
            clearTrackedTimer(composerTypingTimer);
            composerTypingTimer = null;
          }
          composer.classList.remove('is-typing');
          composer.classList.add('is-ready');
          composerSendTimer = setTrackedTimeout(() => {
            composerSendTimer = null;
            composer.classList.add('is-sending');
            if (typeof onComplete === 'function') onComplete();
          }, 220);
        }
      }, step);
    }

    function clamp01(n) {
      return Math.min(1, Math.max(0, n));
    }

    function safeUrl(input) {
      if (typeof input !== 'string' || !input.trim()) return null;
      try {
        // Accept protocol-relative URLs (//host/path) and relative paths by using document.baseURI
        let candidate = input.trim();
        if (candidate.startsWith('//') && typeof location !== 'undefined' && location.protocol) {
          candidate = location.protocol + candidate; // e.g. https://example.com/...
        }
        const base = (typeof document !== 'undefined' && document.baseURI) ? document.baseURI : location.href;
        const url = new URL(candidate, base);
        if (!['http:', 'https:', 'blob:', 'data:'].includes(url.protocol)) return null;
        return url.href;
      } catch (err) {
        // helpful debug logging for broken media paths
        console.warn('safeUrl: invalid or unsupported URL:', input, err && err.message);
        return null;
      }
    }

    function applyToneSettings(opts = {}) {
      const { preset, url, volume, volumeDb, gain, playbackRate, rate } = opts;
      let targetSrc = null;
      const presetKey = (preset || '').toLowerCase();

      if (typeof url === 'string' && url.trim()) {
        targetSrc = safeUrl(url.trim());
      } else if (presetKey && tonePresets[presetKey]) {
        targetSrc = tonePresets[presetKey];
      } else if (presetKey === 'default') {
        targetSrc = tonePresets.default;
      }

      if (targetSrc) {
        snd.src = targetSrc;
        snd.load();
      }

      const volRaw = volume ?? volumeDb ?? gain;
      if (volRaw !== undefined && volRaw !== null) {
        const parsed = parseFloat(volRaw);
        if (Number.isFinite(parsed)) snd.volume = clamp01(parsed);
      }

      const rateRaw = playbackRate ?? rate;
      if (rateRaw !== undefined && rateRaw !== null) {
        const parsedRate = parseFloat(rateRaw);
        if (Number.isFinite(parsedRate) && parsedRate > 0) snd.playbackRate = parsedRate;
      }
    }

    const themeParam = (qs('theme') || '').toLowerCase();
    const colorSchemeQuery =
      typeof matchMedia === 'function' ? matchMedia('(prefers-color-scheme: light)') : null;

    function applyTheme(mode) {
      const themeClass = mode === 'light' ? 'theme-light' : 'theme-dark';
      document.body.classList.remove('theme-light', 'theme-dark');
      document.body.classList.add(themeClass);
    }

    if (themeParam === 'auto' && colorSchemeQuery) {
      applyTheme(colorSchemeQuery.matches ? 'light' : 'dark');
      const handleSchemeChange = (event) => applyTheme(event.matches ? 'light' : 'dark');
      if (colorSchemeQuery.addEventListener) {
        colorSchemeQuery.addEventListener('change', handleSchemeChange);
      } else if (colorSchemeQuery.addListener) {
        colorSchemeQuery.addListener(handleSchemeChange);
      }
    } else if (themeParam === 'light' || themeParam === 'dark') {
      applyTheme(themeParam);
    } else {
      applyTheme('dark');
    }

    if (qs('transparent') === '1') document.body.classList.add('trans');

    applyToneSettings({
      preset: qs('tone'),
      url: qs('toneUrl'),
      volume: qs('toneVolume'),
      playbackRate: qs('toneRate') ?? qs('toneSpeed')
    });

    const startBg = qs('bg');
    if (startBg) setBackground(startBg);

    document.addEventListener('keydown', (event) => {
      if (event.key && event.key.toLowerCase() === 'c') {
        panel.classList.toggle('hidden');
      }
    });

    const panelParam = (qs('panel') || '').toLowerCase();
    if (['1', 'true', 'on', 'yes'].includes(panelParam)) {
      panel.classList.remove('hidden');
    }

    let demo = [];
    let demoState = null;
    const demoReady = loadDemoSequence();

    async function loadDemoSequence() {
      let data = Array.isArray(window.offlineDemo) ? window.offlineDemo : [];
      const customSpec = qs('customChat') ?? qs('chat') ?? qs('demoUrl');

      if (typeof customSpec === 'string' && customSpec.trim()) {
        const customData = await resolveCustomChat(customSpec);
        if (Array.isArray(customData)) {
          data = customData;
        } else {
          console.warn('Konnte customChat nicht laden – verwende Offline-Demo.');
        }
      }

      demo = data;
      populateParticipants();
    }

    async function resolveCustomChat(spec) {
      const trimmed = spec.trim();
      if (!trimmed) return null;

      try {
        const parsed = JSON.parse(trimmed);
        if (Array.isArray(parsed)) return parsed;
      } catch (err) {}

      try {
        let base = trimmed.replace(/\s+/g, '');
        if (/^[A-Za-z0-9+\/_-]+={0,2}$/.test(base)) {
          base = base.replace(/-/g, '+').replace(/_/g, '/');
          while (base.length % 4) base += '=';
          const decoded = atob(base);
          const parsed = JSON.parse(decoded);
          if (Array.isArray(parsed)) return parsed;
        }
      } catch (err) {}

      try {
        const url = new URL(trimmed, location.href);
        if (!['http:', 'https:'].includes(url.protocol)) return null;
        const res = await fetch(url.toString());
        if (!res.ok) {
          console.warn('customChat URL antwortete mit Status', res.status);
          return null;
        }
        const text = await res.text();
        try {
          const parsed = JSON.parse(text);
          if (Array.isArray(parsed)) return parsed;
          console.warn('customChat URL lieferte kein Array.');
        } catch (err) {
          console.warn('customChat URL enthielt kein gültiges JSON.');
        }
      } catch (err) {
        console.warn('customChat Parameter konnte nicht verarbeitet werden.', err);
      }

      return null;
    }

    function populateParticipants() {
      const names = [];
      for (const it of demo) {
        const m = it.msg || it;
        if (m && m.name && !names.includes(m.name)) names.push(m.name);
      }
      const el = document.getElementById('participants');
      if (!el) return;
      const max = 5;
      if (names.length === 0) el.textContent = 'Teilnehmer: —';
      else if (names.length > max) el.textContent = 'Teilnehmer: ' + names.slice(0, max).join(', ') + ', …';
      else el.textContent = 'Teilnehmer: ' + names.join(', ');
    }

    (function handleHeaderParam() {
      const hdr = qs('header');
      if (hdr === '0' || hdr === 'false' || hdr === 'hide') {
        const header = document.getElementById('chatHeader');
        if (header) header.classList.add('hidden');
      }
    })();

    let ws;
    let wsUrl = qs('ws');
    let wsReconnectTimer = null;
    let wsRetries = 0;

    if (wsUrl) connectWS(wsUrl);

    function scheduleReconnect(url) {
      if (wsReconnectTimer) return;
      const base = Math.min(15000, 500 * Math.pow(2, wsRetries));
      const jitter = base * (0.8 + Math.random() * 0.4);
      const delay = Math.max(500, jitter || 500);
      wsRetries += 1;
      wsReconnectTimer = setTrackedTimeout(() => {
        wsReconnectTimer = null;
        connectWS(url);
      }, delay);
    }

    function connectWS(url) {
      try {
        ws = new WebSocket(url);
      } catch (err) {
        console.error('WebSocket Fehler beim Verbindungsaufbau', err);
        scheduleReconnect(url);
        return;
      }

      ws.onopen = () => {
        wsRetries = 0;
        if (wsReconnectTimer) {
          clearTrackedTimer(wsReconnectTimer);
          wsReconnectTimer = null;
        }
      };

      ws.onclose = () => {
        scheduleReconnect(url);
      };

      ws.onerror = () => {
        scheduleReconnect(url);
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleCommand(data);
        } catch (err) {
          console.warn('Ungültige WS-Payload', err);
        }
      };
    }

    function sanitize(str) {
      return (str || '').replace(/[&<>"']/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
    }

    function nowStr() {
      const d = new Date();
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function createMeta(name, time) {
      const meta = document.createElement('div');
      meta.className = 'meta';
      const nameEl = document.createElement('span');
      nameEl.className = 'name';
      nameEl.textContent = name;
      const timeEl = document.createElement('span');
      timeEl.className = 'time';
      timeEl.textContent = time || nowStr();
      meta.append(nameEl, timeEl);
      return meta;
    }

    function appendMedia(container, media) {
      const safe = safeUrl(media);
      if (!safe) return;
      const wrap = document.createElement('div');
      wrap.className = 'media';
      wrap.dataset.loaded = '0';

      if (/\.(mp4|webm|mov)(\?|$)/i.test(safe)) {
        const video = document.createElement('video');
        video.src = safe;
        video.preload = 'metadata';
        video.playsInline = true;
        video.muted = true;
        video.loop = true;
        video.autoplay = true;
        video.setAttribute('disablepictureinpicture', '');
        video.setAttribute('controlslist', 'nodownload noplaybackrate');
        video.controls = true;
        video.addEventListener('loadedmetadata', () => {
          if (video.videoWidth && video.videoHeight) {
            wrap.style.aspectRatio = `${video.videoWidth} / ${video.videoHeight}`;
          }
          wrap.dataset.loaded = '1';
          maybeAutoScroll(360);
        });
        wrap.appendChild(video);
      } else {
          const img = document.createElement('img');
          img.decoding = 'async';
          // keep lazy so the browser can defer if needed
          img.loading = 'lazy';
          img.alt = '';

          // Append the img immediately so the browser can show loading state or broken image icon
          // and so layout reflects eventual image size when it arrives.
          img.addEventListener('load', () => {
            try {
              if (img.naturalWidth && img.naturalHeight) {
                wrap.style.aspectRatio = `${img.naturalWidth} / ${img.naturalHeight}`;
              } else {
                // fallback: keep the default 16:9
              }
              wrap.dataset.loaded = '1';
            } catch (e) {
              console.warn('media load handler error', e);
            }
            maybeAutoScroll(360);
          });
          img.addEventListener('error', (ev) => {
            // keep the frame visible and mark as not-loaded; log for debugging
            wrap.dataset.loaded = '0';
            console.warn('media failed to load:', safe, ev);
            // optionally show a subtle placeholder background instead of removing the element
            // keep wrap in DOM so user sees the intended media slot
          });

          // set src after listeners attached
          img.src = safe;
          // ensure the img is present in the DOM so loading/broken state is visible
          wrap.appendChild(img);
      }

      container.appendChild(wrap);
    }

    let typingTl = null;

    function setTyping(on = true, name = '', avatar = '', role = 'them') {
      if (!on) {
        hideComposerShell();
        playTypingRowExitAnimation();
        if (typingTl) {
          typingTl.kill();
          typingTl = null;
        }
        const dots = typingRow.querySelectorAll('.dot');
        gsap.set(dots, { opacity: 0.3, scale: 1 });
        maybeAutoScroll(360);
        return;
      }

      if (role === 'me') {
        hideComposerShell();
        showComposerShell();
        setComposerTextValue('');
        playTypingRowExitAnimation();
        if (typingTl) {
          typingTl.kill();
          typingTl = null;
        }
        maybeAutoScroll(360);
        return;
      }

      hideComposerShell();
      playTypingRowEnterAnimation();
      typingAvatar.src = safeUrl(avatar) || `https://i.pravatar.cc/64?u=${encodeURIComponent(name || 'avatar')}`;
      typingRow.classList.remove('me', 'them');
      typingRow.classList.add('them');

      const bubble = typingRow.querySelector('.bubble');
      if (typingRow.firstElementChild !== typingAvatar) {
        typingRow.insertBefore(typingAvatar, bubble);
      }

      const dots = typingRow.querySelectorAll('.dot');
      gsap.set(dots, { opacity: 0.3, scale: 1 });
      if (typingTl) {
        typingTl.kill();
        typingTl = null;
      }
      if (prefersReducedMotion) {
        gsap.set(dots, { opacity: 0.6, scale: 1 });
        return;
      }
      typingTl = gsap.timeline({ repeat: -1, defaults: { ease: 'power2.inOut', duration: 0.4 } });
      dots.forEach((dot, index) => {
        typingTl.to(dot, { scale: 1.2, opacity: 1 }, index === 0 ? 0 : '-=0.2');
        typingTl.to(dot, { scale: 1, opacity: 0.3 }, '+=0.1');
      });
      maybeAutoScroll(360);
    }

    // Mark: cluster-helper
    function updateClusterClasses(bubblesEl) {
      if (!bubblesEl) return;
      const bubbles = Array.from(bubblesEl.querySelectorAll('.bubble'));
      bubbles.forEach((b) => b.classList.remove('is-single', 'is-first', 'is-middle', 'is-last'));
      if (bubbles.length === 1) {
        bubbles[0].classList.add('is-single');
        return;
      }
      bubbles.forEach((b, i) => {
        if (i === 0) b.classList.add('is-first');
        else if (i === bubbles.length - 1) b.classList.add('is-last');
        else b.classList.add('is-middle');
      });
    }

    function addMessage({
      role = 'them',
      name = 'Person',
      avatar = '',
      text = '',
      media = null,
      time = null,
      revealDuration = null,
      quote = null,
      onComplete = null,
      __fromComposer = false
    }) {
      if (role === 'me' && !__fromComposer) {
        const hasText = typeof text === 'string' && text.trim().length > 0;
        if (composer && hasText) {
          const chainedComplete = () => {
            try {
              if (typeof onComplete === 'function') {
                onComplete();
              }
            } finally {
              setTyping(false, '', '', 'me');
            }
          };
          typeComposerSequence(text, revealDuration, () => {
            addMessage({
              role,
              name,
              avatar,
              text,
              media,
              time,
              revealDuration: null,
              quote,
              onComplete: chainedComplete,
              __fromComposer: true
            });
          });
          return;
        }
      }

      const lastRow = scrollEl.lastElementChild;
      const canGroup =
        lastRow &&
        lastRow.classList &&
        lastRow.classList.contains('row') &&
        lastRow.classList.contains(role) &&
        lastRow.dataset &&
        lastRow.dataset.name === name;

      const bubble = document.createElement('div');
      bubble.className = 'bubble';

      if (quote && (quote.text || quote.name)) {
        const q = document.createElement('div');
        q.className = 'quote';
        const qa = document.createElement('span');
        qa.className = 'q-author';
        qa.textContent = quote.name || 'Zitat';
        const qt = document.createElement('span');
        qt.className = 'q-text';
        qt.innerHTML = sanitize(quote.text || '').replace(/\n/g, '<br/>');
        q.append(qa, qt);
        bubble.appendChild(q);
      }

      const textContainer = document.createElement('div');
      textContainer.className = 'text';
      if (!revealDuration) {
        textContainer.innerHTML = sanitize(text).replace(/\n/g, '<br/>');
      }
      bubble.appendChild(textContainer);

      if (media) {
        appendMedia(bubble, media);
      }

      if (!canGroup) {
        bubble.appendChild(createMeta(name, time));
      }

      let targetRow = lastRow;

      if (canGroup) {
        let group = targetRow.querySelector('.bubbles');
        if (!group) {
          group = document.createElement('div');
          group.className = 'bubbles';
          const existingBubble = Array.from(targetRow.children).find((c) => c.classList && c.classList.contains('bubble'));
          if (existingBubble) {
            targetRow.insertBefore(group, existingBubble);
            group.appendChild(existingBubble);
          }
        }
        group.appendChild(bubble);
        updateClusterClasses(group);
        if (!prefersReducedMotion) {
          gsap.fromTo(bubble, { opacity: 0, y: 8, scale: 0.98 }, { opacity: 1, y: 0, scale: 1, duration: 0.36, ease: 'power2.out' });
        }
        maybeAutoScroll(420);
      } else {
        const row = document.createElement('div');
        row.className = `row ${role}`;
        row.dataset.name = name;
        const avatarImg = document.createElement('img');
        avatarImg.className = 'avatar';
        avatarImg.src = safeUrl(avatar) || `https://i.pravatar.cc/64?u=${encodeURIComponent(name)}`;
        avatarImg.alt = 'avatar';

        const bubbleGroup = document.createElement('div');
        bubbleGroup.className = 'bubbles';
        bubbleGroup.appendChild(bubble);
        updateClusterClasses(bubbleGroup);

        if (role === 'them') {
          row.append(avatarImg, bubbleGroup);
        } else {
          row.append(bubbleGroup, avatarImg);
        }

        scrollEl.appendChild(row);

        if (!prefersReducedMotion) {
          gsap.fromTo(
            row,
            { x: role === 'them' ? -50 : 50, opacity: 0, scale: 0.85 },
            { x: 0, opacity: 1, scale: 1, duration: 0.5, ease: 'power2.out' }
          );
        }

        maybeAutoScroll(600);
      }

      if (revealDuration && revealDuration > 0) {
        const originalText = String(text || '');
        let idx = 0;
        const total = originalText.length;
        const interval = Math.max(10, Math.round(revealDuration / Math.max(1, total)));
        const timer = setTrackedInterval(() => {
          idx += 1;
          const currentSlice = originalText.slice(0, idx);
          const safeSlice = sanitize(currentSlice).replace(/\n/g, '<br/>');
          textContainer.innerHTML = safeSlice;
          scrollFollowDuringTyping();
          if (idx >= total) {
            clearTrackedTimer(timer);
            if (typeof onComplete === 'function') onComplete();
          }
        }, interval);
      } else if (typeof onComplete === 'function') {
        onComplete();
      }

      try {
        snd.currentTime = 0;
        snd.play().catch(() => {});
      } catch (err) {}
    }

    function typingDurationFor(text) {
      const clean = String(text || '').trim();
      const len = Math.max(0, clean.length);
      const base = 350;
      const perChar = 45;
      let dur = base + perChar * len;
      if (len < 6) dur = Math.max(dur, 520);
      const mul = 0.85 + Math.random() * 0.4;
      dur = Math.round(dur * mul);
      return Math.max(350, Math.min(dur, 5000));
    }

    function clampDelay(val, fallback = 0) {
      const num = Number(val);
      if (!Number.isFinite(num) || num < 0) return fallback;
      return num;
    }

    function stopDemo() {
      if (demoState && demoState.timer) {
        clearTrackedTimer(demoState.timer);
      }
      demoState = null;
    }

    function clearChat() {
      const hadReconnectTimer = Boolean(wsReconnectTimer);
      stopDemo();
      clearAllTimers();
      cancelSmoothScroll();
      userLocked = false;
      lockTimerId = null;
      wsReconnectTimer = null;
      if (typingTl) {
        typingTl.kill();
        typingTl = null;
      }
      setTyping(false, '', '', 'them');
      gsap.killTweensOf('*');
      scrollEl.innerHTML = '';
      maybeAutoScroll(0);
      if (hadReconnectTimer && wsUrl && (!ws || ws.readyState !== WebSocket.OPEN)) {
        scheduleReconnect(wsUrl);
      }
    }

    function setBackground(url) {
      const safe = safeUrl(url);
      if (!safe) {
        bgVid.pause();
        bgVid.removeAttribute('src');
        bgVid.load();
        bgImg.removeAttribute('src');
        bgImg.style.display = 'none';
        bgVid.style.display = 'none';
        return;
      }
      if (/\.(mp4|webm|mov)(\?|$)/i.test(safe)) {
        bgVid.pause();
        bgVid.removeAttribute('src');
        bgVid.load();
        bgVid.src = safe;
        bgVid.load();
        bgVid.style.display = 'block';
        bgImg.style.display = 'none';
        if (!prefersReducedMotion) {
          gsap.fromTo(bgVid, { opacity: 0 }, { opacity: 1, duration: 1 });
        } else {
          bgVid.style.opacity = '1';
        }
        const playPromise = bgVid.play?.();
        if (playPromise && typeof playPromise.catch === 'function') {
          playPromise.catch(() => {});
        }
      } else {
        bgVid.pause();
        bgVid.removeAttribute('src');
        bgVid.load();
        bgImg.src = safe;
        bgImg.style.display = 'block';
        bgVid.style.display = 'none';
        if (!prefersReducedMotion) {
          gsap.fromTo(bgImg, { opacity: 0 }, { opacity: 1, duration: 1 });
        } else {
          bgImg.style.opacity = '1';
        }
      }
    }

    function handleCommand(cmd) {
      switch (cmd.type) {
        case 'msg':
          addMessage(cmd);
          break;
        case 'typing':
          setTyping(!!cmd.on, cmd.name || '', cmd.avatar || '', cmd.role || 'them');
          break;
        case 'clear':
          clearChat();
          break;
        case 'bg':
          setBackground(cmd.url || '');
          break;
        case 'tone':
          applyToneSettings(cmd);
          break;
        case 'ping':
          if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: 'pong' }));
          break;
        case 'demo':
          runDemo();
          break;
        default:
          console.warn('Unknown cmd', cmd);
      }
    }

    async function runDemo() {
      await demoReady;
      if (!Array.isArray(demo) || demo.length === 0) {
        console.warn('Keine Demo-Nachrichten gefunden.');
        return;
      }
      console.log('DEMO_START');
      clearChat();
      const state = { timer: null };
      demoState = state;
      let index = 0;

      const step = () => {
        if (demoState !== state) return;
        if (index >= demo.length) {
          setTyping(false, '', '', 'them');
          demoState = null;
          console.log('DEMO_END');
          return;
        }

        const item = demo[index++];
        const delay = clampDelay(item.delay, 0);
        state.timer = setTrackedTimeout(() => {
          if (demoState !== state) return;

          if (item.typing && !item.msg) {
            const next = demo.slice(index).find((it) => it.msg);
            const nextMsg = next && next.msg;
            const text = nextMsg ? nextMsg.text || '' : '';
            const dur = (item.typingDuration ?? next?.typingDuration ?? nextMsg?.typingDuration) || typingDurationFor(text);
            const role = nextMsg ? nextMsg.role || 'them' : 'them';
            const name = nextMsg ? nextMsg.name : '';
            const avatar = nextMsg ? nextMsg.avatar : '';
            setTyping(true, name, avatar, role);
            state.timer = setTrackedTimeout(() => {
              if (demoState !== state) return;
              setTyping(false, '', '', role);
              step();
            }, dur);
            return;
          }

          if (item.msg) {
            const message = item.msg;
            const text = message.text || '';
            const role = message.role || 'them';
            const dur = (item.typingDuration ?? message.typingDuration) || typingDurationFor(text);
            setTyping(true, message.name, message.avatar, role);
            if (role === 'me') {
              addMessage({ ...message, revealDuration: dur, onComplete: () => {
                if (demoState !== state) return;
                setTyping(false, '', '', 'me');
                step();
              } });
            } else {
              state.timer = setTrackedTimeout(() => {
                if (demoState !== state) return;
                setTyping(false, '', '', role);
                addMessage(message);
                step();
              }, dur);
            }
            return;
          }

          step();
        }, delay);
      };

      step();
    }

    document.getElementById('send').onclick = () => {
      const payload = {
        type: 'msg',
        role: document.getElementById('role').value,
        name: document.getElementById('name').value || 'Person',
        avatar: document.getElementById('avatar').value,
        text: document.getElementById('text').value,
        media: document.getElementById('media').value || null,
        quote:
          document.getElementById('quoteText') && document.getElementById('quoteText').value
            ? {
                name: (document.getElementById('quoteAuthor') && document.getElementById('quoteAuthor').value) || 'Zitat',
                text: document.getElementById('quoteText').value
              }
            : null
      };

      if (payload.role === 'me') {
        const dur = typingDurationFor(payload.text);
        setTyping(true, payload.name, payload.avatar, 'me');
        addMessage({ ...payload, revealDuration: dur, onComplete: () => setTyping(false, '', '', 'me') });
      } else {
        addMessage(payload);
      }

      if (ws && ws.readyState === WebSocket.OPEN) {
        try {
          ws.send(JSON.stringify(payload));
        } catch (err) {
          console.warn('Senden über WS fehlgeschlagen', err);
        }
      }

      document.getElementById('text').value = '';
      document.getElementById('media').value = '';
      if (document.getElementById('quoteAuthor')) document.getElementById('quoteAuthor').value = '';
      if (document.getElementById('quoteText')) document.getElementById('quoteText').value = '';
    };

    document.getElementById('demo').onclick = () => handleCommand({ type: 'demo' });
    document.getElementById('clear').onclick = () => handleCommand({ type: 'clear' });
    document.getElementById('bgbtn').onclick = () => handleCommand({ type: 'bg', url: document.getElementById('bgurl').value });

    if (!wsUrl) runDemo();
  </script>
</body>
</html>
