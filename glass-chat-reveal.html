<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chat → Glass Shatter → Zitat</title>
<style>
  :root{
    --bg:#0b141a;
    --panel:#111a20cc;
    --bubble-me:#005c4b;
    --bubble-them:#202c33;
    --text:#e9edef;
    --muted:#8ea1a8;
    --accent:#25d366;
  }
  html,body{height:100%;margin:0;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;}
  .stage{position:fixed;inset:0;overflow:hidden;background:radial-gradient(1200px 800px at 50% 40%, #0f1820, #06090d 60%, #000 100%);}
  /* Chat overlay (shown first 7s) */
  .chat{
    position:absolute; inset:0; display:grid; place-content:end center; pointer-events:none;
    padding:clamp(16px,4vmin,36px);
  }
  .phone {
    width:min(92vw,420px); height:min(72vh,720px);
    border-radius:28px; background:linear-gradient(180deg,#0d171d,#0a1217);
    box-shadow:0 20px 60px #000a, inset 0 0 0 1px #ffffff10; display:flex; flex-direction:column;
    overflow:hidden; border:1px solid #ffffff14;
  }
  .status{
    padding:12px 16px; color:#c8d1d6; font-size:12px; letter-spacing:.08em; text-transform:uppercase;
    background:#0f1b22; border-bottom:1px solid #ffffff10;
  }
  .messages{ flex:1; overflow:hidden; padding:18px 14px; display:flex; flex-direction:column; gap:10px;}
  .row{ display:flex; gap:8px; max-width:80%;}
  .row.them{ justify-content:flex-start;}
  .row.me{ justify-content:flex-end; align-self:flex-end;}
  .bubble{
    padding:10px 12px; border-radius:16px; color:var(--text); font-size:14px; line-height:1.35;
    box-shadow:0 1px 0 #0006; border:1px solid #ffffff10; backdrop-filter: blur(4px);
  }
  .them .bubble{ background:var(--bubble-them);}
  .me .bubble{ background:var(--bubble-me);}
  .inputbar{
    display:flex; gap:10px; align-items:center; padding:10px 12px; background:#0f1b22; border-top:1px solid #ffffff10;
  }
  .pill{flex:1; background:#0c151b; color:#9fb2bd; padding:10px 12px; border-radius:999px; font-size:13px; border:1px solid #ffffff14;}
  .send{font-size:13px; color:#fff; background:linear-gradient(180deg,#2fe07c,#1bbd60); padding:10px 14px; border-radius:999px; border:0;}

  /* Three.js canvas container on top (we’ll render glass + text here) */
  canvas.webgl{ position:absolute; inset:0; display:block; }

  /* Quote fallback (if WebGL fails) */
  .quote-fallback{
    position:absolute; inset:auto 0 6vh 0; text-align:center; color:#e9edf0; font-size:clamp(22px,4vw,40px); opacity:.0;
    text-shadow:0 2px 20px #000c; padding:0 24px; font-weight:600;
  }

  /* Fade helpers */
  .fade-out{ animation:fadeOut 0.7s ease forwards; }
  @keyframes fadeOut{ to{ opacity:0; transform:translateY(6px) scale(.995);} }
</style>
</head>
<body>
<div class="stage">
  <div class="chat" id="chat">
    <div class="phone">
      <div class="status">⚡ Theater-Chat — Live</div>
      <div class="messages" id="msgs"></div>
      <div class="inputbar">
        <div class="pill">Nachricht schreiben…</div>
        <button class="send" disabled>Senden</button>
      </div>
    </div>
  </div>
  <div class="quote-fallback" id="quoteFallback">„Man sieht nur mit dem Herzen gut. Das Wesentliche ist für die Augen unsichtbar.“</div>
  <canvas class="webgl" id="webgl"></canvas>
</div>

<!-- Three.js + Troika (ES modules) -->
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { Text } from 'https://cdn.jsdelivr.net/npm/troika-three-text@0.49.0/dist/troika-three-text.esm.js';
  import gsap from 'https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js';

  // ---------- Tiny chat script (7s of life) ----------
  const script = [
    {t:  300, who:'them', text:'Hey, seid ihr bereit für die Show?'},
    {t: 1000, who:'them', text:'Licht steht, Ton steht… 🎭'},
    {t: 1700, who:'me'  , text:'Stream startet gleich. Viel Spaß!'},
    {t: 2400, who:'them', text:'Letzte Probe… und go!'},
    {t: 3100, who:'me'  , text:'3… 2… 1… ✨'}
  ];
  const msgs = document.getElementById('msgs');
  const mkRow = (who, text) => {
    const row = document.createElement('div');
    row.className = `row ${who}`;
    const b = document.createElement('div');
    b.className = 'bubble';
    b.textContent = text;
    row.appendChild(b);
    return row;
  };
  (async () => {
    for (const line of script) {
      await new Promise(r => setTimeout(r, line.t));
      msgs.appendChild(mkRow(line.who, line.text));
      msgs.scrollTop = msgs.scrollHeight;
    }
  })();

  // ---------- Three.js scene ----------
  const canvas = document.getElementById('webgl');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  const setSize = () => renderer.setSize(window.innerWidth, window.innerHeight);
  setSize();

  const scene = new THREE.Scene();
  // Moody environment light
  const hemi = new THREE.HemisphereLight(0xb2c7ff, 0x0b0d10, 0.6);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(2,3,4);
  scene.add(dir);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
  camera.position.set(0, 0.2, 6);
  scene.add(camera);

  // Controls (disabled by default; enable if you want to inspect)
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enabled = false;

  // Subtle background plane (just to catch light)
  const bg = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 12),
    new THREE.MeshStandardMaterial({ color: 0x0a1116, metalness:0, roughness:1 })
  );
  bg.position.set(0,0,-2.5);
  scene.add(bg);

  // Quote (Troika text) behind the glass
  const quote = new Text();
  quote.text = '„Man sieht nur mit dem Herzen gut.\nDas Wesentliche ist für die Augen unsichtbar.“';
  quote.fontSize = 0.5;
  quote.maxWidth = 8.5;
  quote.anchorX = 'center';
  quote.anchorY = 'middle';
  quote.position.set(0, 0.2, -0.6);
  quote.color = 0xe9edf0;
  quote.outlineWidth = 0.01;
  quote.outlineColor = 0x0c141b;
  quote.outlineOpacity = 0.6;
  quote.letterSpacing = 0.0;
  quote.sync();
  scene.add(quote);

  // Subtitle author
  const author = new Text();
  author.text = '— Antoine de Saint-Exupéry';
  author.fontSize = 0.22;
  author.anchorX = 'center';
  author.anchorY = 'top';
  author.position.set(0, -1.1, -0.6);
  author.color = 0xaec4cf;
  author.opacity = 0.9;
  author.sync();
  scene.add(author);

  // --------- Procedural "glass" shard generator ----------
  // We generate wedge sectors and concentric rings, then extrude each polygon -> shards
  const shardGroup = new THREE.Group();
  scene.add(shardGroup);

  function makeShards(opts={}){
    const {
      radius=4, rings=3, minSectors=10, maxSectors=16, thickness=0.02,
      jitter=0.25, curvature=0.04
    } = opts;

    const ringR = [];
    for (let i=1;i<=rings;i++){
      // non-linear spacing for nicer distribution
      const t = i/(rings+0.6);
      ringR.push(radius * (0.2 + 0.8 * Math.pow(t, 0.9)));
    }

    const impactAngleOffset = Math.random() * Math.PI*2;

    let prevAngles = [];
    for (let i=0;i<rings;i++){
      const sectors = Math.floor(THREE.MathUtils.lerp(minSectors, maxSectors, Math.random()));
      const angles = [];
      let base = impactAngleOffset + Math.random()*0.4 - 0.2;
      for (let s=0; s<sectors; s++){
        base += (Math.PI*2)/sectors + THREE.MathUtils.randFloatSpread(0.1);
        angles.push(base);
      }
      angles.sort((a,b)=>a-b);

      const rIn  = i===0 ? 0 : ringR[i-1];
      const rOut = ringR[i];

      // Create polygonal ring sectors
      for (let s=0; s<angles.length; s++){
        const a0 = angles[s];
        const a1 = angles[(s+1)%angles.length];
        const mid = (a0+a1)/2;

        // Build a slightly curved wedge shape (adds glass-like irregularity)
        const shape = new THREE.Shape();
        const arcPts = 10;

        const innerPts = [];
        const outerPts = [];
        for (let k=0;k<=arcPts;k++){
          const t = k/arcPts;
          const ai = THREE.MathUtils.lerp(a0, a1, t);
          const bend = 1 + curvature * Math.sin((t-0.5)*Math.PI*2);
          innerPts.push(new THREE.Vector2(
            (rIn * bend) * Math.cos(ai),
            (rIn * bend) * Math.sin(ai)
          ));
          outerPts.push(new THREE.Vector2(
            (rOut * bend) * Math.cos(ai + THREE.MathUtils.randFloatSpread(jitter*0.06)),
            (rOut * bend) * Math.sin(ai + THREE.MathUtils.randFloatSpread(jitter*0.06))
          ));
        }

        // Assemble shape path
        shape.moveTo(innerPts[0].x, innerPts[0].y);
        for (let p=1;p<innerPts.length;p++) shape.lineTo(innerPts[p].x, innerPts[p].y);
        for (let p=outerPts.length-1;p>=0;p--) shape.lineTo(outerPts[p].x, outerPts[p].y);
        shape.closePath();

        const geo = new THREE.ExtrudeGeometry(shape, {
          depth: thickness,
          bevelEnabled: false
        });
        // Center depth to +/- around z=0
        geo.translate(0,0,-thickness/2);

        const mat = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          metalness: 0.0,
          roughness: 0.05,
          transmission: 0.95,   // real glass
          thickness: 0.2,
          reflectivity: 0.5,
          ior: 1.5,
          transparent: true
        });
        const shard = new THREE.Mesh(geo, mat);

        // Tiny per-shard curvature/tilt and randomization
        shard.position.z = THREE.MathUtils.randFloatSpread(0.005);
        shard.rotation.z = THREE.MathUtils.randFloatSpread(0.02);
        shard.userData.midAngle = mid;
        shard.userData.rOut = rOut;
        shard.userData.random = Math.random();

        shardGroup.add(shard);
      }
      prevAngles = angles;
    }
  }

  makeShards({ radius:3.8, rings:4, minSectors:11, maxSectors:17, thickness:0.03, jitter:0.35, curvature:0.05 });

  // Orient glass in front of camera
  shardGroup.rotation.x = THREE.MathUtils.degToRad(0);
  shardGroup.position.z = 0.0;

  // Subtle pre-shatter idle sparkle
  let tSpark = 0;

  // ---------- Animate / Render ----------
  const clock = new THREE.Clock();
  function tick(){
    const dt = clock.getDelta();
    tSpark += dt;
    // Slight index-of-refraction "twinkle" with light by rotating directional light a hair
    dir.position.x = Math.sin(tSpark*0.3)*2 + 2;
    dir.position.y = 3 + Math.cos(tSpark*0.25)*0.3;
    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }
  tick();

  window.addEventListener('resize', ()=>{
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    setSize();
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // ---------- Shatter timeline (after 7s) ----------
  const chat = document.getElementById('chat');
  const quoteFallback = document.getElementById('quoteFallback');

  function shatter(){
    // Fade chat UI
    chat.classList.add('fade-out');

    // Cinematic: short camera push + tilt
    gsap.timeline()
      .to(camera.position, { duration:0.35, z:5.4, ease:'power2.inOut' }, 0)
      .to(camera.rotation, { duration:0.6, x:THREE.MathUtils.degToRad(-2), ease:'power3.out' }, 0);

    // Animate shards: explosive outward motion with depth & spin
    shardGroup.children.forEach((mesh, i)=>{
      const delay = 0.05 + mesh.userData.random * 0.15;
      const dirAngle = mesh.userData.midAngle + THREE.MathUtils.randFloatSpread(0.3);
      const power = THREE.MathUtils.lerp(0.8, 1.7, mesh.userData.random);
      const radius = THREE.MathUtils.lerp(2.5, 7.5, power);
      const upKick = THREE.MathUtils.lerp(0.2, 1.3, Math.random());
      const out = new THREE.Vector3(
        Math.cos(dirAngle) * radius,
        Math.sin(dirAngle) * radius,
        THREE.MathUtils.randFloat(0.6, 2.4)
      );

      // position animate
      gsap.to(mesh.position, { x: out.x, y: out.y, z: out.z, duration:1.1, delay, ease:'expo.out' });

      // rotation animate
      gsap.to(mesh.rotation, {
        x: THREE.MathUtils.randFloat(-2.2, 2.2),
        y: THREE.MathUtils.randFloat(-2.2, 2.2),
        z: mesh.rotation.z + THREE.MathUtils.randFloat(-1.2, 1.2),
        duration:1.2, delay, ease:'expo.out'
      });

      // slight scale/“ping” for impact
      gsap.fromTo(mesh.scale,
        { x:1, y:1, z:1 },
        { x:THREE.MathUtils.randFloat(1.02,1.08), y:THREE.MathUtils.randFloat(1.02,1.08), z:1,
          yoyo:true, repeat:1, duration:0.2, delay:delay-0.03, ease:'power2.out' });
    });

    // Reveal quote (in case WebGL is blocked, fade fallback)
    gsap.to(quoteFallback, { opacity:1, duration:1.0, delay:0.2, ease:'power2.out' });

    // Optional: ease camera back a bit once shards have flown
    gsap.to(camera.position, { duration:1.2, delay:0.9, z:6.2, ease:'power2.out' });
  }

  // Start shatter after 7 seconds
  setTimeout(shatter, 7000);
</script>
</body>
</html>
